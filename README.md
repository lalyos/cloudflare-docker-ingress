# Cloudflare Docker Ingress

Automatic Cloudflare Tunnel ingress controller for Docker containers using convention over configuration.
Its similar to traefik with docker backend, or https://github.com/nginx-proxy/nginx-proxy but uses cloudflare tunnels.

**Docker Image:** `lalyos/cf-docker-ing`

## Features

- **Zero Configuration**: Containers automatically get `<container-name>.<your-domain>` hostnames
- **Auto Port Detection**: If a container exposes a single port, it's automatically used
- **Dynamic Updates**: Routes are added/removed as containers start/stop
- **Single Tunnel**: All containers share one Cloudflare tunnel for efficiency
- **Label Overrides**: Customize behavior when needed

## Quick Start

### 1. Prerequisites

- Docker and Docker Compose installed
- Cloudflare account with a domain


## Step 1: Configure Environment Variables

**Recommended:** Run the setup wizard to automatically generate your `.env`:

```bash
./setup.sh
```

Or manually fill in the values:

- `CLOUDFLARE_API_TOKEN` - API token (create at https://dash.cloudflare.com/profile/api-tokens)
- `CLOUDFLARE_DOMAIN` - Your domain (e.g., `example.com`)
- `CLOUDFLARE_ZONE_ID` - Zone ID for your domain (dashboard/select domain/scroll down/bottom right)
- `CLOUDFLARE_ACCOUNT_ID` - Your Cloudflare account ID (same as above)
- `CLOUDFLARE_TUNNEL_NAME` - Name for your tunnel (e.g., `docker-tunnel`)

- The Cloudflare API token needs following permissions:
  - `Account.Cloudflare Tunnel:Edit`
  - `Zone.DNS:Edit`

- See: "Manual API Token Setup" below

### 3. Start the Tunnel Manager

```bash
docker-compose up -d
```

This will start both:
- **Tunnel Manager** - Monitors Docker containers, creates DNS records, and pushes ingress configuration
- **Cloudflared** - Establishes the tunnel connection using the token from `.env`


### 5. Deploy Your Applications

The tunnel manager automatically detects containers on the same Docker network.

#### Example: Simple Web App

```yaml
name: myproject

services:
  web:
    image: nginx:alpine
    ports:
      - "80"
```

Start your app:

```bash
docker-compose up -d
```

Your app is now accessible at: `http://web.myproject.yourdomain.com`

## Configuration

### Environment Variables

Edit `.env` file:

| Variable | Required | Description | Default |
|----------|----------|-------------|---------|
| `CLOUDFLARE_API_TOKEN` | Yes | API token (generated by setup.sh) | - |
| `CLOUDFLARE_DOMAIN` | Yes | Base domain for hostnames | - |
| `CLOUDFLARE_ZONE_ID` | Yes | Zone ID (from setup.sh) | - |
| `CLOUDFLARE_ACCOUNT_ID` | Yes | Account ID (from setup.sh) | - |
| `CLOUDFLARE_TUNNEL_NAME` | Yes | Tunnel name (from setup.sh) | - |
| `CLOUDFLARE_TUNNEL_ID` | Yes | Tunnel ID (from setup.sh) | - |
| `CLOUDFLARE_TUNNEL_TOKEN` | Yes | Tunnel token (from setup.sh) | - |

**Important:** Run `./setup.sh` to automatically generate all values and create the tunnel.

### Convention Rules

1. **Hostname Generation**:
   - **Docker Compose containers**: `<service>.<project>.<CLOUDFLARE_DOMAIN>`
     - Example: Service `web` in project `myapp` → `web.myapp.example.com`
   - **Standalone containers**: `<container-name>.<CLOUDFLARE_DOMAIN>`
     - Example: Container `nginx` → `nginx.example.com`
   - **Custom override**: Use label `cloudflare.tunnel.hostname: "custom.example.com"`

2. **Port Detection**:
   - One exposed port → automatically used
   - Multiple ports → skipped (use label override)
   - No ports → skipped

### Label Overrides

Customize behavior with Docker labels:

```yaml
services:
  my-app:
    image: my-image
    labels:
      # Disable tunnel for this container
      cloudflare.tunnel.enable: "false"

      # Custom hostname
      cloudflare.tunnel.hostname: "custom.example.com"

      # Specific port (when multiple are exposed)
      cloudflare.tunnel.port: "8080"
    ports:
      - "8080"
      - "8081"
```

## How It Works

1. **docker-gen** monitors Docker events for container changes
2. Template extracts container metadata (name, ports, labels)
3. Generates JSON configuration with routing rules
4. Triggers bash script on any change
5. Script:
   - Creates remotely-managed Cloudflare tunnel (if needed)
   - Manages DNS records (CNAME to tunnel)
   - Pushes ingress configuration to Cloudflare API
   - Cleans up removed containers

**Note:** This tool creates a remotely-managed tunnel and pushes configuration via API. Routes update automatically without restarting `cloudflared`. You'll need to run `cloudflared` separately to establish the actual tunnel connection. See [Running Cloudflared](#running-cloudflared) below.


## Troubleshooting

### Manual API Token Setup

1. Go to https://dash.cloudflare.com/profile/api-tokens
2. Click "Create Token"
3. Use "Create Custom Token"
4. Set permissions:
   - **Account** → Cloudflare Tunnel → Edit
   - **Zone** → DNS → Edit
5. Set zone resources to include your domain
6. Create token and copy to `.env` file

### Check Logs

```bash
# Check tunnel manager logs
docker logs cloudflare-tunnel-manager

# Check cloudflared logs
docker logs cloudflared

# Should see: "Registered tunnel connection"
```

### Common Issues

**Cloudflared won't start**
- Check that `CLOUDFLARE_TUNNEL_TOKEN` is set in `.env`
- Check cloudflared logs: `docker logs cloudflared`

**DNS not resolving:**
- Wait a few minutes for DNS propagation
- Check Cloudflare DNS records in your dashboard
- Verify the tunnel manager is running: `docker logs cloudflare-tunnel-manager`

**Tunnel creation fails:**
- Verify API token has Tunnel edit permissions
- Check account ID is correct
- Ensure tunnel name doesn't contain special characters

**Containers not getting tunnels**

- Ensure container has exactly ONE exposed port
- Or add label: `cloudflare.tunnel.port=8080`
- Check generated config: `cat config/tunnel-config.json`