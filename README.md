# Cloudflare Docker Ingress

Automatic Cloudflare Tunnel ingress controller for Docker containers using convention over configuration.
Its similar to traefik with docker backend, or https://github.com/nginx-proxy/nginx-proxy but uses cloudflare tunnels.

Its an elegant solution if your machine doesn't have a public IP address. 

## Features

- **Zero Configuration**: Containers automatically get `<container-name>.<your-domain>` hostnames
- **Auto Port Detection**: If a container exposes a single port, it's automatically used
- **Dynamic Updates**: Routes are added/removed as containers start/stop
- **Single Tunnel**: All containers share one Cloudflare tunnel for efficiency
- **Label Overrides**: Customize behavior when needed

## Quick Start

### 1. Prerequisites

- Docker and Docker Compose installed
- Cloudflare account with a domain

For the domain hosting at Cloudflare you can use the free tier, and you can buy a cheap domain for less than 10 eur/year. (at namecheap: *.lol, *.yo, *.eu)

## Step 1: Configure Environment Variables

**Recommended:** Run the setup wizard to automatically generate your `.env`:

```bash
./setup.sh
```

Or manually fill in the values:

- `CLOUDFLARE_API_TOKEN` - API token (create at https://dash.cloudflare.com/profile/api-tokens)
- `CLOUDFLARE_DOMAIN` - Your domain (e.g., `example.com`)
- `CLOUDFLARE_ZONE_ID` - Zone ID for your domain (dashboard/select domain/scroll down/bottom right)
- `CLOUDFLARE_ACCOUNT_ID` - Your Cloudflare account ID (same as above)
- `CLOUDFLARE_TUNNEL_NAME` - Name for your tunnel (e.g., `docker-tunnel`)

- The Cloudflare API token needs following permissions:
  - `Account.Cloudflare Tunnel:Edit`
  - `Zone.DNS:Edit`

- See: "Manual API Token Setup" below

### 3. Start Services

```bash
docker-compose up -d
```

This starts three containers:
- **cloudflare-tunnel-manager** - Monitors containers, manages DNS and ingress config
- **network-connector** - Connects cloudflared to all Docker networks
- **cloudflared** - Establishes the tunnel connection

### 4. Deploy Your Applications

The tunnel manager automatically detects containers on the same Docker network.

#### Example: Simple Web App

```yaml
name: myproject

services:
  web:
    image: nginx:alpine
    ports:
      - "80"
```

Start your app:

```bash
docker-compose up -d
```

Your app is now accessible at: `http://web.myproject.yourdomain.com`

## Configuration

### Environment Variables

Edit `.env` file:

| Variable | Required | Description | Default |
|----------|----------|-------------|---------|
| `CLOUDFLARE_API_TOKEN` | Yes | API token (generated by setup.sh) | - |
| `CLOUDFLARE_DOMAIN` | Yes | Base domain for hostnames | - |
| `CLOUDFLARE_ZONE_ID` | Yes | Zone ID (from setup.sh) | - |
| `CLOUDFLARE_ACCOUNT_ID` | Yes | Account ID (from setup.sh) | - |
| `CLOUDFLARE_TUNNEL_NAME` | Yes | Tunnel name (from setup.sh) | - |
| `CLOUDFLARE_TUNNEL_ID` | Yes | Tunnel ID (from setup.sh) | - |
| `CLOUDFLARE_TUNNEL_TOKEN` | Yes | Tunnel token (from setup.sh) | - |

**Important:** Run `./setup.sh` to automatically generate all values and create the tunnel.

### Convention Rules

1. **Hostname Generation**:
   - **Docker Compose containers**: `<service>.<project>.<CLOUDFLARE_DOMAIN>`
     - Example: Service `web` in project `myapp` → `web.myapp.example.com`
   - **Standalone containers**: `<container-name>.<CLOUDFLARE_DOMAIN>`
     - Example: Container `nginx` → `nginx.example.com`
   - **Custom override**: Use label `cloudflare.tunnel.hostname: "custom.example.com"`

2. **Port Detection**:
   - One exposed port → automatically used
   - Multiple ports → skipped (use label override)
   - No ports → skipped

### Label Overrides

Customize behavior with Docker labels:

```yaml
services:
  my-app:
    image: my-image
    labels:
      # Disable tunnel for this container
      cloudflare.tunnel.enable: "false"

      # Custom hostname
      cloudflare.tunnel.hostname: "custom.example.com"

      # Specific port (when multiple are exposed)
      cloudflare.tunnel.port: "8080"
    ports:
      - "8080"
      - "8081"
```

## How It Works

The solution consists of three containers:

| Container | Description |
|-----------|-------------|
| `cloudflare-tunnel-manager` | Monitors Docker containers, manages DNS records, pushes ingress config to Cloudflare API |
| `network-connector` | Auto-connects cloudflared to all Docker bridge networks |
| `cloudflared` | Establishes tunnel connection and routes traffic to containers |

**Flow:**
1. **docker-gen** monitors Docker events for container changes
2. Template extracts container metadata (name, ports, labels, IP addresses)
3. Tunnel manager creates DNS records and pushes ingress rules to Cloudflare
4. Network connector ensures cloudflared is connected to all Docker networks
5. Cloudflared routes incoming traffic to containers by IP address

Routes update automatically without restarting any container.


## Troubleshooting

### Manual API Token Setup

1. Go to https://dash.cloudflare.com/profile/api-tokens
2. Click "Create Token"
3. Use "Create Custom Token"
4. Set permissions:
   - **Account** → Cloudflare Tunnel → Edit
   - **Zone** → DNS → Edit
5. Set zone resources to include your domain
6. Create token and copy to `.env` file

### Check Logs

```bash
# Check tunnel manager logs
docker logs cloudflare-tunnel-manager

# Check network connector logs
docker logs network-connector

# Check cloudflared logs
docker logs cloudflared

# Should see: "Registered tunnel connection"
```

### Common Issues

**Cloudflared won't start**
- Check that `CLOUDFLARE_TUNNEL_TOKEN` is set in `.env`
- Check cloudflared logs: `docker logs cloudflared`

**DNS not resolving:**
- Wait a few minutes for DNS propagation
- Check Cloudflare DNS records in your dashboard
- Verify the tunnel manager is running: `docker logs cloudflare-tunnel-manager`

**Tunnel creation fails:**
- Verify API token has Tunnel edit permissions
- Check account ID is correct
- Ensure tunnel name doesn't contain special characters

**Containers not getting tunnels**

- Ensure container has exactly ONE exposed port
- Or add label: `cloudflare.tunnel.port=8080`
- Check generated config: `cat config/tunnel-config.json`